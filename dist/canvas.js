figma.showUI(__html__,{themeColors:!0,width:400,height:512});function i(a,t){const n=`Error ${a}: ${t.message}`;figma.ui.postMessage({type:"error",context:a,message:n})}figma.ui.onmessage=a=>{const t=typeof a=="string"?JSON.parse(a):a;switch(t.type){case"get-selection":c(t);break;case"create-shape":l(t);break;case"close-plugin":figma.closePlugin();break;case"get-analytics":f();break;case"get-user-info":m();break;case"get-ls-data":p(t);break;default:i("processing message",new Error(`Unsupported message type: ${t.type}`))}};function c(a){try{const t=figma.currentPage.selection;if(t.length===0){figma.ui.postMessage({type:"selection-data",data:[],message:"No nodes selected"});return}const n=a.verbose||!1,s=t.map(e=>({id:e.id,name:e.name,type:e.type,visible:e.visible,locked:e.locked,x:e.x,y:e.y,width:e.width,height:e.height,rotation:e.rotation,opacity:e.opacity,parent:e.parent?{id:e.parent.id,name:e.parent.name,type:e.parent.type}:null}));figma.ui.postMessage({type:"selection-data",data:s})}catch(t){i("getting selection",t)}}function l(a){try{const t=a.width||100,n=a.height||100,s=a.radius||50;if(t<=0||n<=0||s<=0)throw new Error("Shape dimensions must be positive values");let e;switch(a.shapeType){case"rect":{e=figma.createRectangle(),e.resize(t,n);break}case"ellipse":{e=figma.createEllipse(),e.resize(t,n);break}case"circle":{e=figma.createEllipse(),e.resize(t,t);break}case"polygon":{e=figma.createPolygon();const r=a.sides||6;if(r<3)throw new Error("Polygons require at least 3 sides");e.pointCount=r,e.resize(s*2,s*2);break}case"star":{e=figma.createStar();const r=a.sides||5;if(r<3)throw new Error("Stars require at least 3 points");e.pointCount=r;const o=a.innerRadius||s*.4;if(o<=0||o>=s)throw new Error("Inner radius must be positive and less than outer radius");e.innerRadius=o,e.resize(s*2,s*2);break}default:throw new Error(`Unsupported shape type: ${a.shapeType}`)}e.x=a.x||0,e.y=a.y||0,figma.currentPage.appendChild(e),figma.currentPage.selection=[e],figma.viewport.scrollAndZoomIntoView([e]),figma.ui.postMessage({type:"shape-created",shapeType:a.shapeType,id:e.id})}catch(t){i("creating shape",t)}}function f(){const a=new Promise((t,n)=>{setTimeout(()=>n(new Error("Analytics timeout: Document may be too large")),1e4)});Promise.race([figma.loadAllPagesAsync(),a]).then(()=>{try{const t=figma.root.children.filter(e=>e.type!=="SECTION").length,n=figma.root.children.reduce((e,r)=>r.type!=="SECTION"?e+r.findAll().length:e,0),s=figma.currentPage.findAll().length;figma.ui.postMessage({type:"analytics-data",totalPages:t,totalLayersInDocument:n,totalLayersInCurrentPage:s})}catch(t){i("getting analytics",t)}}).catch(t=>{i("loading pages",t)})}function m(){try{const a=figma.currentUser;if(!a){figma.ui.postMessage({type:"user-info",user:null,message:"User information not available. You may be working offline."});return}figma.ui.postMessage({type:"user-info",user:{id:a.id,name:a.name,email:a.email}})}catch(a){i("getting user info",a)}}function p(a){const t=a.subCommand||"help",n=a.listCurrent||!1;(async()=>{let e="";try{switch(t){case"fonts":e=(await g(n)).join(`
`)||(n?"No fonts found in current page":"No fonts found");break;case"styles":e=(await u(n)).join(`
`)||(n?"No styles found in current page":"No styles found");break;case"components":e=(await d(n)).join(`
`)||(n?"No components found in current page":"No components found");break;case"help":e=`Available lists:
fonts       : List fonts
styles      : List styles
components  : List components`;break;default:throw new Error(`Unsupported subcommand: ${t}`)}figma.ui.postMessage({type:"ls-data",data:e,subCommand:t})}catch(r){i(`loading ${t} data`,r)}})()}async function g(a){if(a){const t=figma.currentPage.findAll(s=>s.type==="TEXT");if(t.length===0)return[];const n=new Set;for(const s of t)if(s.fontName!==figma.mixed)n.add(`${s.fontName.family} ${s.fontName.style}`);else{const e=s.characters;for(let r=0;r<e.length;r++){const o=s.getRangeFontName(r,r+1);o!==figma.mixed&&n.add(`${o.family} ${o.style}`)}}return Array.from(n)}else return(await figma.getLocalTextStylesAsync()).map(n=>`${n.fontName.family} ${n.fontName.style}`)}async function u(a){if(a){const t=new Set,n=figma.currentPage.findAll(e=>e.type==="TEXT");if(n.length===0)return[];n.forEach(e=>{e.textStyleId!==figma.mixed&&e.textStyleId&&t.add(e.textStyleId)});const s=new Set;return t.forEach(e=>{const r=figma.getStyleById(e);r&&s.add(r.name)}),Array.from(s)}else return(await figma.getLocalTextStylesAsync()).map(n=>n.name)}async function d(a){if(a){const t=figma.currentPage.findAll(e=>e.type==="COMPONENT"),n=figma.currentPage.findAll(e=>e.type==="COMPONENT_SET");return[...t.map(e=>e.name),...n.map(e=>`${e.name} (Set)`)]}else{await figma.loadAllPagesAsync();const t=[];for(const n of figma.root.children)if(n.type!=="SECTION")try{const s=n.findAll(r=>r.type==="COMPONENT"),e=n.findAll(r=>r.type==="COMPONENT_SET");s.forEach(r=>{t.push(`${r.name} (in ${n.name})`)}),e.forEach(r=>{t.push(`${r.name} (Set, in ${n.name})`)})}catch(s){i(`processing page "${n.name}"`,s)}return t}}
